{"version":3,"sources":["App.jsx","index.js"],"names":["App","console","log","window","innerHeight","innerWidth","ROWS","Math","floor","COLS","emptyGrid","Array","fill","neighborsRelativePositions","useState","grid","setGrid","run","setRun","runRef","useRef","current","runSimulation","useCallback","currGrid","produce","copy","i","j","neighbors","forEach","x","y","neighborX","neighborY","setTimeout","href","title","className","onClick","newGrid","push","from","random","style","display","gridTemplateColumns","map","rows","col","key","width","height","backgroundColor","undefined","border","boxSizing","cursor","ReactDOM","render","document","getElementById"],"mappings":"oRAsKeA,MAlKf,WACEC,QAAQC,IAAIC,OAAOC,YAAaD,OAAOE,YAGvC,IAAMC,EAAOC,KAAKC,OAAOL,OAAOC,YAAc,IAAM,IAC9CK,EAAOF,KAAKC,MAAML,OAAOE,WAAa,IAEtCK,EAAY,WAChB,OAAOC,MAAML,GAAMM,KAAKD,MAAMF,GAAMG,MAAK,KAIrCC,EAA6B,CACjC,CAAC,EAAG,GACJ,CAAC,GAAI,GACL,CAAC,EAAG,GACJ,EAAE,EAAG,GACL,CAAC,EAAG,GACJ,CAAC,GAAI,GACL,EAAE,EAAG,GACL,EAAE,GAAI,IApBK,EAwBWC,oBAAS,WAC/B,OAAOJ,OAzBI,mBAwBNK,EAxBM,KAwBAC,EAxBA,OA6BSF,oBAAS,GA7BlB,mBA6BNG,EA7BM,KA6BDC,EA7BC,KAgCPC,EAASC,iBAAOH,GACtBE,EAAOE,QAAUJ,EAGjB,IAAMK,EAAgBC,uBAAY,WAC3BJ,EAAOE,UAIZL,GAAQ,SAAAQ,GAEN,OAAOC,YAAQD,GAAU,SAAAE,GACvB,IADgC,IAAD,WACtBC,GACP,IAF6B,eAEpBC,GAEP,IAAIC,EAAY,EAEhBhB,EAA2BiB,SAAQ,YAAa,IAAD,mBAAVC,EAAU,KAAPC,EAAO,KACvCC,EAAYN,EAAII,EAChBG,EAAYN,EAAII,EAIpBC,GAAa,GACbA,EAAY3B,GACZ4B,GAAa,GACbA,EAAYzB,GACZe,EAASS,GAAWC,IAEpBL,OAQAA,EAAY,GAAKA,EAAY,EAC/BH,EAAKC,GAAGC,IAAK,EACHJ,EAASG,GAAGC,IAAoB,IAAdC,IAC5BH,EAAKC,GAAGC,IAAK,IA3BRA,EAAI,EAAGA,EAAInB,EAAMmB,IAAM,EAAvBA,IADFD,EAAI,EAAGA,EAAIrB,EAAMqB,IAAM,EAAvBA,SAoCbQ,WAAWb,EAAe,QACzB,CAACT,EAA4BJ,EAAMH,IAEtC,OACE,oCACE,gCACE,uBACE8B,KAAK,wDACLC,MAAM,2CAFR,yBAMA,4BACEC,UAAU,aACVC,QAAS,WAEPrB,GAAQD,GACHA,IACHE,EAAOE,SAAU,EACjBC,OAIHL,EAAM,OAAS,QAXlB,eAaA,4BACEsB,QAAS,WAEPvB,EAAQN,OAHZ,cAQA,4BACE6B,QAAS,WAGP,IADA,IAAIC,EAAU,GACLb,EAAI,EAAGA,EAAIrB,EAAMqB,IACxBa,EAAQC,KACN9B,MAAM+B,KAAK/B,MAAMF,IAAO,kBAAOF,KAAKoC,SAAW,GAAM,EAAI,MAG7D3B,EAAQwB,KATZ,WAeF,yBACEI,MAAO,CACLC,QAAS,OACTC,oBAAoB,UAAD,OAAYrC,EAAZ,aAGpBM,EAAKgC,KAAI,SAACC,EAAMrB,GAAP,OACRqB,EAAKD,KAAI,SAACE,EAAKrB,GAAN,OACP,yBACEsB,IAAG,UAAKvB,EAAL,YAAUC,GACbU,UAAU,OACVM,MAAO,CACLO,MAAO,GACPC,OAAQ,GACRC,gBAAiBtC,EAAKY,GAAGC,GAAK,aAAU0B,EACxCC,OAAQ,iBACRC,UAAW,aACXC,OAAQ,WAEVlB,QAAS,WACPvB,EACES,YAAQV,GAAM,SAAAW,GACZA,EAAKC,GAAGC,IAAMb,EAAKY,GAAGC,mBCrJ1C8B,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,W","file":"static/js/main.5c69ad5a.chunk.js","sourcesContent":["import React, { useState, useCallback, useRef } from \"react\";\nimport \"./App.scss\";\nimport produce from \"immer\";\n\nfunction App() {\n  console.log(window.innerHeight, window.innerWidth);\n\n  // Compute the number of rows and cols, knowing that the header is 50px tall and each cell is a 20px square\n  const ROWS = Math.floor((window.innerHeight - 50) / 20);\n  const COLS = Math.floor(window.innerWidth / 20);\n\n  const emptyGrid = () => {\n    return Array(ROWS).fill(Array(COLS).fill(false)); // Init the matrix with empty cells\n  };\n\n  // List all relative positions of a cell. This array is used to reduce the code when checking the state of neighboring cells\n  const neighborsRelativePositions = [\n    [0, 1],\n    [0, -1],\n    [1, 0],\n    [-1, 0],\n    [1, 1],\n    [1, -1],\n    [-1, 1],\n    [-1, -1]\n  ];\n\n  // Initialize the grid with empty cells\n  const [grid, setGrid] = useState(() => {\n    return emptyGrid();\n  });\n\n  // Simulation not running by default\n  const [run, setRun] = useState(false);\n\n  // Reference of the running state. Usefull to access within the simulation function\n  const runRef = useRef(run);\n  runRef.current = run;\n\n  // Run the simulation. MemoÃ¯zed.\n  const runSimulation = useCallback(() => {\n    if (!runRef.current) {\n      return; // Stop the simulation when the running state is false\n    }\n\n    setGrid(currGrid => {\n      // Immer return a copy of the grid\n      return produce(currGrid, copy => {\n        for (let i = 0; i < ROWS; i++) {\n          for (let j = 0; j < COLS; j++) {\n            // 1 - Calculate the number of neighbors\n            let neighbors = 0;\n\n            neighborsRelativePositions.forEach(([x, y]) => {\n              const neighborX = i + x; // X position of neighbor to test\n              const neighborY = j + y; // Y position of neighbor to test\n\n              // Test if the neighbor is within the grid limits, and increment the number of neighbors if its cell is alive\n              if (\n                neighborX >= 0 &&\n                neighborX < ROWS &&\n                neighborY >= 0 &&\n                neighborY < COLS &&\n                currGrid[neighborX][neighborY]\n              ) {\n                neighbors++;\n              }\n            });\n\n            // 2 - Kill or revive the cell given the following rules :\n            //    - Any live cell with two or three neighbors survives.\n            //    - Any dead cell with three live neighbors becomes a live cell.\n            //    - All other live cells die in the next generation. Similarly, all other dead cells stay dead.\n            if (neighbors < 2 || neighbors > 3) {\n              copy[i][j] = false;\n            } else if (!currGrid[i][j] && neighbors === 3) {\n              copy[i][j] = true;\n            }\n          }\n        }\n      });\n    });\n\n    // Recursively call the simulation to process the next phase.\n    setTimeout(runSimulation, 100);\n  }, [neighborsRelativePositions, COLS, ROWS]);\n\n  return (\n    <>\n      <header>\n        <a\n          href=\"https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\"\n          title=\"Wikipedia page of Conway's game of life\"\n        >\n          Conway's Game of Life\n        </a>\n        <button\n          className=\"run-button\"\n          onClick={() => {\n            // Toggle the running state, and run the simulation accordingly\n            setRun(!run);\n            if (!run) {\n              runRef.current = true;\n              runSimulation();\n            }\n          }}\n        >\n          {run ? \"Stop\" : \"Start\"} simulation\n        </button>\n        <button\n          onClick={() => {\n            // Regenerate an empty grid\n            setGrid(emptyGrid());\n          }}\n        >\n          Clear grid\n        </button>\n        <button\n          onClick={() => {\n            // Generate a grid randomly. Each cell has 70% chance to be a dead one to not instantly kill all cells by over-population\n            let newGrid = [];\n            for (let i = 0; i < ROWS; i++) {\n              newGrid.push(\n                Array.from(Array(COLS), () => (Math.random() > 0.7 ? 1 : 0))\n              );\n            }\n            setGrid(newGrid);\n          }}\n        >\n          Random\n        </button>\n      </header>\n      <div\n        style={{\n          display: \"grid\",\n          gridTemplateColumns: `repeat(${COLS}, 20px)`\n        }}\n      >\n        {grid.map((rows, i) =>\n          rows.map((col, j) => (\n            <div\n              key={`${i}-${j}`}\n              className=\"cell\"\n              style={{\n                width: 20,\n                height: 20,\n                backgroundColor: grid[i][j] ? \"black\" : undefined,\n                border: \"solid 1px #aaa\",\n                boxSizing: \"border-box\",\n                cursor: \"pointer\"\n              }}\n              onClick={() => {\n                setGrid(\n                  produce(grid, copy => {\n                    copy[i][j] = !grid[i][j];\n                  })\n                );\n              }}\n            />\n          ))\n        )}\n      </div>\n    </>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}